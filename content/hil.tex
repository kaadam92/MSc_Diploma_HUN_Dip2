\chapter{HIL felépítése}

Nyilvánvaló tehát, hogy napjainkban, a modern teljesítmény elektronikai eszközök fejlesztéséhez elengedhetetlen a HIL szimulátor alkalmazása. Bár az eszköz fejlesztése jelentős terhet ró a készítőkre, segítségével csökkenthető a tervezésre fordítandó idő, a fejlesztési folyamatok párhuzamosításával. Segítségével elkerülhetőek a költséges és veszélyes hibák a fejlesztés alatt, hiszen a teljesítmény elektronikai elemek csak matematikai modell formájában jelennek meg a rendszerben. Ezen felül a tesztelés minősége is jelentősen javítható a költségek csökkentése mellett. Ilyen szimulátorból sok futhat egymás mellett párhuzamosan, a valós elektronika többszöri felépítése nélkül. Így sok különböző teszteset futtatható egyszerre, akár ciklikusan, emberi felügyelet nélkül. \cite{dirac}

\section{Hardware felépítése}

A HIL szimulátor hardware nem más, mint egy interface elektronika a vezérlő hardware-ek és a szimulációt végző FPGA között. \Afigref{hw_architect} ábrán láthatóak a vezérést végző elemek. A HIL szimulátor feladata a bal oldali, Power Subsystem blokkból érkező jelek előállítása, illetve a vezérlő jelek fogadása.

\subsection{CCB és MCB csatlakozó}
\todo[inline]{Meg kell rendesen foglalmani a kis mondandóm}
A szimuláció során a PIB nem szükséges, ezért az MCB és a CCB kapcsolatát is a HIL elektronika biztosítja. A két eszköz között a kommunikáció UART-on valósul meg. A kivitelezés számomra több szempontból is érdekes, mert a sebesség $9\ Mbaud$, illetve a fizikai réteg sem teljesen szokványos. Az UART jelek differenciálisan kerülnek átvitelre az MCB felé, de az Rx és a Tx egy-egy külön érpárt kapott. Az MCB-n keresztül érkeznek még ezen felül a \emph{Sto1X} és a \emph{Sto2X} jelek. Ezek a jelek szintén speciálisak, az eszköz vészleállításáért felnek. A CCB-vel való kommunikáció \aref{table:ccbsignals}. táblázatban felsorolt jelek segítségével valósul meg. 

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Név}   & \textbf{I/O} & \textbf{A/D} & \textbf{Leírás}                 \\ \hline
UoutU          & Digital      & Bemenet      & Az U fázis nullátmenetének jele \\ \hline
UoutV          & Digital      & Bemenet      & A V fázis nullátmenetének jele  \\ \hline
UoutW          & Digital      & Bemenet      & A W fázis nullátmenetének jele  \\ \hline
Sto1SatusX     & Digital      & Bemenet      &                                 \\ \hline
Sto2SatusX     & Digital      & Bemenet      &                                 \\ \hline
MCB\_TxD       & Digital      & Kimenet      &                                 \\ \hline
MCB\_RxD       & Digital      & Bemenet      &                                 \\ \hline
EEPROM\_SDA    & Digital      & Be/Kimenet   &                                 \\ \hline
EEPAROM\_SCL   & Digital      & Kimenet      &                                 \\ \hline
RectStatusC    & Digital      & Bemenet      &                                 \\ \hline
PrechargeCtrlX & Digital      &              &                                 \\ \hline
IgbtBFltX      & Digital      &              &                                 \\ \hline
IgbtBRdy       & Digital      &              &                                 \\ \hline
IgbtBRstX      & Digital      &              &                                 \\ \hline
IgbtPsuCtrlX   & Digital      &              &                                 \\ \hline
IgbtInvFltX    & Digital      &              &                                 \\ \hline
IgbtInvRdy     & Digital      &              &                                 \\ \hline
IgbtInvRstX    & Digital      & Kimenet      &                                 \\ \hline
IgbtU1         & Digital      & Kimenet      &                                 \\ \hline
IgbtU2         & Digital      & Kimenet      &                                 \\ \hline
IgbtV1         & Digital      & Kimenet      &                                 \\ \hline
IgbtV2         & Digital      & Kimenet      &                                 \\ \hline
IgbtW1         & Digital      & Kimenet      &                                 \\ \hline
IgbtW2         & Digital      & Kimenet      &                                 \\ \hline
IgbtB          & Digital      & Kimenet      &                                 \\ \hline
FanPsuCtrC     & Digital      & Kimenet      &                                 \\ \hline
FanExtCtrC     & Digital      & Kimenet      &                                 \\ \hline
FanIntCtrC     & Digital      & Kimenet      &                                 \\ \hline
FanExtSpeedC1  & Digital      & Kimenet      &                                 \\ \hline
FanExtSpeedC2  & Digital      & Kimenet      &                                 \\ \hline
5V\_Loopback   & Power        &              &                                 \\ \hline
TIgbtW         & Analog       & Bemenet      &                                 \\ \hline
15VCM          & Analog       & Bemenet      &                                 \\ \hline
TIgbtV         & Analog       & Bemenet      &                                 \\ \hline
UdcMN          & Analog       & Bemenet      &                                 \\ \hline
UdcMP          & Analog       & Bemenet      &                                 \\ \hline
IWN            & Analog       & Bemenet      &                                 \\ \hline
IWP            & Analog       & Bemenet      &                                 \\ \hline
TIgbtU         & Analog       & Bemenet      &                                 \\ \hline
TIgbtB         & Analog       & Bemenet      &                                 \\ \hline
IUP            & Analog       & Bemenet      &                                 \\ \hline
IUN            & Analog       & Bemenet      &                                 \\ \hline
IVP            & Analog       & Bemenet      &                                 \\ \hline
IVN            & Analog       & Bemenet      &                                 \\ \hline
TA             & Analog       & Bemenet      &                                 \\ \hline
5VSto1         & Analog       & Bemenet      &                                 \\ \hline
5VSto2         & Analog       & Bemenet      &                                 \\ \hline
UdcP           & Analog       & Bemenet      &                                 \\ \hline
UdcN           & Analog       & Bemenet      &                                 \\ \hline
\end{tabular}
\caption{A CCB jelei}
\label{ccbsignals}
\end{table}

Ezek azok a jelek, amiket a HIL-nek vagy szimulálnia, vagy pedig fogadnia kell. Kivételt képez ez alól az \emph{5V\_Loopback}. Ennek a funkciója az, hogy létre lehet hozni a PIB-en olyan áramköri részeket, melyek az $5\ V$-os táplálást csak a CCB-n keresztül kapják meg, így nem indulnak el csatlakoztatott kártya nélkül.

A digitális jelek esetében a feladat egyszerű, csak a CCB és az FPGA közti jelszint különbséget kell megoldani. Ebben egy \emph{74LVC8T245PW} típusú level-shifter lesz segítségünkra. A CCB a jelekt $5\ V$-os tartományban adja ki, illetve fogadja, az FPGA maximális kiementi feszültésge $3,3\ V$, és nem is állnak rendelkezésre nagyobb feszültséget toleráló lábak. A kisebb feszültségre való átalakításra lehetséges megoldás a feszültségosztó is, de a nagysebességű jelek dinamikájának megőrzése érdekében inkább itt is a level-shiftert választottam. A lassabb jelek esetében maradtam a feszültségosztóval való megoldásnál.

Analóg jeleket tekintve csak bemenet találhat óa CCB-n. Ezen jelek előállítását Sigma-Delta átalakítók segítségével oldottam meg, melyről részletesebben később lesz szó.

A fent említett jeleken kívül a HIL-en elhelyeésre került az ULINK és az St-Link debuggerek csatlakozója is, a fejlesztés kényelmesebbé tételének érdekében. A CCB-re a JTAG jelei egy külön flat-flex kábel segítségével csatlakoznak. Ennek a mechanikai teherbíása igen alacsony, így pedig nem kell egy külön kártyára csatlakoztatni, kockáztatva ezzel az elmozdulást, kontakthibát vagy vezetékszakadást.

\todo[inline]{Blokkvázlat a HIL-ről}

\subsection{Tápegység}
A kártya $24 V$-os tápfeszültségre lett tervezve. Ebből egy Linear Technologies \emph{LT3845AEFE#PBF} szinkron buck tápegység vezérlő IC és a hozzá tartozó külső apparátus állítja aelő az $5 V$-os tápfeszültséget mind az FPGA mind pedig a CCB számára. A tápegység maximálisan $6 A$ terhelhetőségű, amely előser soknak tűnhet, de az FPGA fogyasztását jelentpsen befolyásolja a benne található firmware, így elképzelhető az kapacitás teljes felhasználása is, kis teljesítmény esetén edig hatékony tud maradni az ún. \emph{Burst mode} működési mód segítségével.

\subsection{ZTEX kártya}

Egy iylen teszt és fejlesztési eszköz fejlesztése során az egyik legfontosabb szempont a modularitás. Nem láthatjuk előre feltétlenül, hogy a későbbiekben mire lesz szükség. Az FPGA önmagában biztosít modularitást, hiszen cserélhető benne a hardware, jelen esetben a megvalósított matematikai modell. Ezen felül egy közel 500 lábbal rendelkező BGA tokos FPGA-hoz a nyáktervezés sem triviális feladat. A megfelelő lábak kivezetéséhez legalább 6-8 rétegre van szükség, és nagyon sok hibalehetőséget tartogat magában. Ezek miatt egy FPGA modul alkalmazása mellett döntöttünk. Bár az elérhető GPIO lábak mennyisége így korlátoztt, az FPGA-t működtető áramkör garantáltan működőképes, illetve a saját tervezésű elektornika bonyolultsága is jelentősen csökken.

\begin{figure}[!ht]
	\centering
	\includegraphics[width = 0.75\textwidth]{figures/fpga216.jpg}
	\caption{A ZTEX 2.16 FPGA board} 
	\label{fig:ztex}
\end{figure}

\Aref{fig:ztex} ábrán látható ZTEX panel mellett tettem le a voksom. A kártyáról kivezetésre kerültek a JTAG interfész jelei is, azonban az ehhez az FPGA-hoz való Xilinx debugger nem áll rendelkezésre. A ZTEX kártyán azonban egy Cypress mikorovezérlő segítségével, \emph{libusb} driver segítségével betölthető a bitstream mind a RAM-ba, ideiglenes teszthez, mind pedig a FLASH-be, melyből az FPGA minden indítás során be tudja olvadni azt.


\begin{figure}[!ht]
	\centering
	\includegraphics[width = 0.8\textwidth]{figures/usb-fpga-216.png}
	\caption{A ZTEX 2.16 FPGA board felépítése} 
	\label{fig:ztex_block}
\end{figure}

\todo[inline]{Képhiba}

Ezen felül a rajta található Xilinx Artix 7 FPGA megfelelő hűtését is biztosítja a panel. Az FPGA főbb datai \aref{table:artix7spec} táblázatban láthatóak. Ez az eszköz a Xilinx jelegelg kereskedelemi forgalomban kapható egyik zászlóshajója, amit bizonyít is a ZTEX panel 500 Eurós vételára.

\begin{table}[]
\centering
\begin{tabular}{ll}
Logikai cellák               & 215360 \\
Szeletek                     & 33650  \\
CLB Flip-flopok              & 269200 \\
Eloszott memória (kb)        & 2888   \\
Blokk RAM/FIFO (36 kb/darab) & 365    \\
Blokk RAM összesen (kb)      & 13140  \\
                             &        \\
                             &        \\
                             & 
  
\end{tabular}
\caption{A Xilinx Artix 7 XC7A200T}
\label{artix7spec}    
\end{table}

Bár a jelenlegi modell mindössze 10\%-át foglalja le a teljes hardwarenek, a későbbi bővülésre is hagy lehetőséget. A fimware elkészítésére és fejlesztésére a Xilinx Vivado környezet biztosít lehetőséget. Ebben készült el a keretrendszer, mely a Simulinkból generált HDL fájlokat tudja fogadni, megfelelő interfészen keresztül a kártyára vezetni.


\subsection{Szigma-Delta (\Sigma\Delta)\ átalakítók}

Az FPGA nem rendelkezik analóg kiementekkel, azonban a CCB számára elő kell állítani a normál működés során visszamért analóg jeleket, hiszen ebben relik a szimulátor lényege, a vezérlő elektronika szmszögéből nincsen különbség a valós hardware és a szimulátor között. A szigma delta átalakító nagyon nagy vonalakban egy órajel és egy fix impulzusszélességű négyszögjel, mely vagy logikai egy értéket, vagy logikai nulla értéket vesz fel az órajel minden felfutó (vagy lefutó) élére. Az így kialakult impulzusjel kitöltési tényezője egy hosszabb mintavételi ablakot tekintve arányos a bemeneti kódszóval. Ezek után a jelet egy az órajelnél sokkal kisebb vágási frekvenciájú aluláteresztő szűrűvel feldolgozva analóg jelet kapunk. A szigma delta átalakító további előnye a PWM kimenethez képest, hogy a kvantálái zajt nagyfrekvenciás tartományba tolja.\cite{artofelectronics}

Igen félrevezető névvel szokás "1 bites DA" átalakítónak is nevezni. A kifejezés egyszerűséget és alacsony teljesítményt sugall, ennek ellenére a megoldás rendkívül lineáris és nagy felbontású eredményt ad, így elterjedten használják pl. audio eszközökben is.

A mi esetünkben két részre bontható az átalakító. A modellben fut egy analógjelből digitális jelet létrehozó szigma-delta átalakító, majd az így kiadott digitális jelet szűrjük már az FPGA-n kívül egy aluláteresztő szűrűvel. \Aref{fig:sigmadelta} ábra szemlélteti az átalakító működését. A bejövő analalóg jelből levonjuk a hibajelet, majd egy komparátor összehasonlítja egy referenciával. Amennyiben nagyobb a bejövő jel, a kimenet logikai "1" értéket vesz fel, ha kisebb, logikai "0"-t. Ezt a jelet, egy 1-bites DAC-on keresztül vezetve akkumuláljuk, így kialakítva a hibajelet. 

\begin{figure}[!h]
	\centering
	\includegraphics[width = 0.75\textwidth]{figures/sigmadelta.png}
	\caption{A szigma-delta átalakító} 
	\label{fig:sigmadelta}
\end{figure}

Az így kapott jelet már a modellből az FPGA lábára vezethetjük. Mivel az FPGA kiemeneti bankjainak feszültsége maximum $3,3\ V$, ezért a szűrés után erősítésre is szükség lehet.

\begin{figure}[!h]
	\centering
	\includegraphics[width = \textwidth]{figures/lowpassfilter.png}
	\caption{A négyszögjelet fogadó aluláteresztő szűrő} 
	\label{fig:lowpass}
\end{figure}

\Aref{fig:lowpass} ábrán látható aluláteresztő szűrő kimenet már közvetlenül a CCB analóg bemenetére csatalkozik. A CCB analóg mérései differenciálisak a valóságban, mivel a valós enelktronikában sokkal nagyobb zaj éri a rendszert. A modellen azonban ez a zavar nem jelentős, így a mérés negatív jelét földre kötjük.

\section{Simulink modell}

A futtatandó modell magában foglalja a teljesítményelektronikai elemek modelljét, egy motor modellt és egy mechanikai terhelés modellt. Hiányossaág volt a modellnek, hogy a DC link feszültésge egy konstans érték volt, így a különböző terhelések DC feszültségre való visszahatásást nem lehetett vizsgálni. További hiányosság, hogy a hálózat paramétereit sem vette így figyelembe a modell.

\subsection{A rendelkezésre álló modell}

\Aref{fig:original_model}. ábrán látható a korábban elkészített modell és az egyes blokkok kapcsolata. Jó kiniduló alapot biztosított, jól megfigyelhető rajta a rendszer működése. Ez a modell bemenetként tekint a DC feszültségre, így az én bemeneti modellemet ezen kívül helyeztem el. A terhelés a bemeneti modellben DC terhelőáram formájában jelentkezik, így ezt a jelet elő kellett még állítani. A rendelkezésre álló félhíd modell csak az AC áramot állítja elő kiemenetként, így ezt módosítani kellett, hogy a DC áram is előálljon. Ezek után a három félhíd áramát összegezve felhasználhatóvá vált az I_{DC} terhelőáram, bemenetként a DC kört is tartalmazó modellemnek.


\begin{figure}[]
	\centering
	\includegraphics[width = \textwidth]{figures/hil_blokkvazlat.png}
	\caption{A SIMULINK model} 
	\label{fig:original_model}
\end{figure}

Az I_{DC} terhelőáramot az alábbi egyenletek segítségével határozhatjuk meg:

\begin{equation}
\centering
$$
I_{DC}
=
\begin{cases}
I_{AC}   & ha \  PWM_H = 1 \  | \  PWM_H = 0 \  \& \  I_{AC} < 0 \\
0 & 
\end{cases}
$$    
\end{equation}

A módosítások \aref{fig:igbt_model}. ábra alsó részén láthatóak. Ebből a modellből valóstja meg együttesen három darab az inverter kimeneti fokozatának modelljét. 

\begin{figure}[]
	\centering
	\includegraphics[width = \textwidth]{figures/igbt_model.png}
	\caption{A módosított félhíd modell} 
	\label{fig:igbt_model}
\end{figure}




\subsection{Az implementált bemeneti modell}

\begin{figure}[]
	\centering
	\includegraphics[width = \textwidth]{figures/model_continous.pdf}
	\caption{A frekvenciaváltó bemenetének folytonos modellje} 
	\label{fig:cont_input_model}
\end{figure}

A feladat tehát az volt, hogy a korábbi modellt egészítsem ki egy olyan blokkal ami a felsorolt hiányosságokat orvosolja. Az elkészítendő modellnek tartalmaznia kell tehát egy háromfázisú hálózatmodellt, a diódás hidat, a bemeneti DC folytót, illetve a DC link kondenzátort. A modellezendő főáramkori részt \aref{fig:input_marked} ábrán jelöltem. 

\begin{figure}[H!]
	\centering
	\includegraphics[width = \textwidth]{figures/VFDschematic_choke_marked.png}
	\caption{A frekvenciaváltó bemenetének folytonos modellje} 
	\label{fig:input_marked}
\end{figure}

A számítások megkönnyítése érdekében célszerű a háromfázisú hálózatot x-y komponensekkel reprezentálni. Erre azért van lehetőség, mert a három mennyiség által reprezentált információt lehetséges csupán két jellel ábrázolni. A háromfázisú mennyiségekből az alábbi összefüggés segítségével az x és y összetevőket.

\begin{equation}
$$
\centering
\begin{bmatrix}
       U_x\\[0.3em]
       U_y\\[0.3em]
       U_0 
\end{bmatrix}
=
\begin{bmatrix}
       \frac{2}{3} & -\frac{1}{3} & -\frac{1}{3}  \\[0.3em]
       0 & \frac{1}{\sqrt{3}} & -\frac{1}{\sqrt{3}}  \\[0.3em]
       \frac{1}{3} & \frac{1}{3} & \frac{1}{3}    
\end{bmatrix}
\begin{bmatrix}
       U_a\\[0.3em]
       U_b\\[0.3em]
       U_c    
\end{bmatrix}
$$
\end{equation}

Ezek után a hálózatparamétereket csak két ,,fázison'' kell figyelembe venni.  Ezek a hálózat paraméterek egy soros R-L modellel lettek figyelembe véve. Az így előállt x és y komponensű áramokból inverz Clarke-transzformáció segítségével elő tudjuk állítani a három fázisáramot. A diódák ideális töréspontos karakterisztikával kerültek modellezésre. Ez azt jelenti, hogy az áram értékek negatív komponensét levágjuk a pozitív értékek pedig változtatás nélkül továbbításra kerülnek. Az így kapott áramokat összegezve megkapjuk a DC fojtó áramát. A modellalkotás ezen pontján komplikációk merülnek fel, mert a diódaáramokból nem következik közvetelnül a fojtó árama, ezért itt az álapotávltozókat szétválasztjuk egy virtuális R-C tag bevezetésével. Ennek segítségével bevezethető ezen a ponton is egy potenciál, így pedig a DC fojtó könnyedén modellezhetővé válik. A DC fojtó árama és a terhelő áram különbsége tölti a DC kondenzátort, amelyen így létrejön a DC feszültség.


\begin{equation}
$$
\centering
\begin{bmatrix}
       U_a\\[0.3em]
       U_b\\[0.3em]
       U_c          
\end{bmatrix}
=
\begin{bmatrix}
       1 & 0 & 1  \\[0.3em]
       -\frac{1}{2} & \frac{\sqrt{3}}{2} & 1  \\[0.3em]
       -\frac{1}{2} & -\frac{\sqrt{3}}{2} & 1 
\end{bmatrix}
\begin{bmatrix}
       U_x\\[0.3em]
       U_y\\[0.3em]
       U_0,,        
\end{bmatrix}
$$    
\end{equation}


%\begin{equation}
%    \centering
%    U_a+U_b+U_c = 0
%\end{equation}

\begin{figure}[H!]
	\centering
	\includegraphics[width = \textwidth]{figures/continous_testrun_1.png}
	\caption{A folytonos modell szimulációja} 
	\label{fig:cont_run}
\end{figure}


\subsection{Áttérés diszrét időre}

Az eddig mevalósított hálózatmodell folytonos idejű, Laplace tartományban ábárzolt egyenletekkel. Az FPGA, mint minden digitális rendszer azonban diszkrét időben fogja ezeket megoldani. Emiatt a modellt át kell traszformálni \emph{z} tartományba. Az integrátor matematikailag az alábbi alaknak felel meg:

\begin{equation}
\centering
\frac{1}{s} \Rightarrow \frac{1}{1-z^{-1}}
\end{equation}

Ez az átalakítás a modellben grafikusan pedig az alábbi módon jelentkezik:

\begin{figure}[H!]
	\centering
	\includegraphics[width = \textwidth]{figures/integrator.png}
	\caption{Az integrázor diszkrét idejű megvalósítása} 
	\label{fig:integrator}
\end{figure}

Tehát az összes integrátor blokkon el kell végezni a fenti átalakítást.

\todo[inline]{Itt még ki kéne egészíteni z tartomány beli rizsával}

\subsection{Fixpontos ábárzolás}

Az FPGA-ban hatékonyan csak fixpontos aritmetika valósítható meg, így a most lebegőpontos változóinkat át kell alakítanunk fixpontosra. Ez könnyen megoldható, hiszen az egyes változók értéktartománya előre ismert, pl tudjuk, hogy a DC feszültség biztosan kisebb, mint $U_{DC}=1000\ V$.

A lebegépontos számábárolás megkülönböztet egyszeres (floating) és kétszeres (double) precizitást. Előbbi a számot 32 utóbbi pedig 64 biten tárolja.

\begin{figure}[H]
	\centering
	\includegraphics[width = 0.8\textwidth]{figures/floating.png}
	\caption{A lebegőpontos számábrázolás} 
	\label{fig:floating}
\end{figure}

Ilyen módon a floating körülbelül 7, a double pedig 17 tizedesjegy pontosságot enged meg. Mindkét ábrázolásmód 1 darab előjel bitet után mantissza és exponens formájában tárolja a számot. A mantissza normál alakban, a kettedespont mögötti biteket tárolja. A normálak biztosítja, hogy a kettedespont előtt már csak garantáltan 1 darab 1-es van, így ez elhagyható. Az exponens pedig egy a kettedespont helyét tárolja úgy, hogy a valós kitevő 127-el csökkentve van.

A fixpontos ábrázolás ezzel szemben rögzíti a tizedespont helyét, valamint azt nem kódolja a változóban, hanem a típusa határozza meg az értelmezés módját.

\todo[inline]{Írni kell még a fixpontos dolgokról}

A Simulink alapbeállításként double változóként hozza létre a jeleket és dolgozik velük. 